<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PA-X &amp; WEP Dataverse </title>
    <link href="https://fonts.googleapis.com/css?family=Calistoga|Roboto+Slab|Oxygen+Mono&display=swap"
          rel="stylesheet">
    <script src="src/js/lib/d3.min.js"></script>
    <style>

        div.tooltip {
            font-family: 'Oxygen Mono', monospace;
            position: absolute;
            text-align: left;
            /*width: 100px;*/
            /*height: 40px;*/
            padding: 10px;
            /*font: 18px sans-serif;*/
            background: rgba(0, 0, 0, 1);
            color: white;
            /*text-shadow: #fff 1px 0 10px;*/
            border: 0px;
            /*border-radius: 8px;*/
            pointer-events: none;
        }

        body {

            background-color: #F3F1E5;
            /*background-color: #F3F1E5;*/
            width: 100%;
            margin-top: 200px; /* TODO: modify page layout */
        }

        #info {

            display: block;
            width: 70%;
            font: 15px sans-serif;
            font-family: Arial, sans-serif;
            margin: 0px auto;
            height: 40vh;
        }

        #peaceProcessName {
            font-family: 'Roboto Slab', serif;
            font-size: 20px;
        }

        #agreementTitle {
            /*font-family: 'Roboto Slab', serif;*/
            font-family: 'Calistoga', cursive;
            margin-bottom: 70px;
            /* TODO: modify page layout */
        }

        #signedDate {
            /*font-family: 'Roboto Slab', serif;*/
        }

        #status {
            text-transform: capitalize;
        }

        #agreementType {
            text-transform: capitalize;
        }

        #svgContainer {
            /*background-color: #F3F1E5;*/
            width: 100%;
            height: 50vh;
            /*border: 1px solid #aaa;*/
            overflow: hidden;
        }

        #svgWrapper {
            height: 100%;
            margin-bottom: -50px; /* maximum width of scrollbar */
            padding-bottom: 50px; /* maximum width of scrollbar */
            overflow-y: hidden;
            overflow-x: scroll;
        }

        svg {
            /*height: 100%;*/
            margin: 0px auto;
            display: block;
            /*    overflow-x: hidden;*/
        /
        }

        #timeline {
            font: 1.7em sans-serif;
            font-weight: 700;
            stroke: black;
            stroke-width: 2px;

        }

        #timeline text {
            fill: black;
            letter-spacing: 10px;
            opacity: 0.3;
        }

        .line {
            fill: none;
            /*stroke: #686847;*/
            stroke-width: 6px;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: black;
            }

            #info {
                color: white;
            }

            rect {
                fill: white;
            }

            #timeline {
                fill: red;
                stroke: white;
            }

            #timeline text {
                fill: white;
                opacity: 0.5;
            }

            .dot {
                fill: white;
            }
        }
    </style>
</head>
<body>
<script>
    // INITIALIZE HTML AND SVG AREA

    let margin = {top: 20, right: 20, bottom: 70, left: 20},
        width = 6000 - margin.left - margin.right,
        singleSideHeight = 300 - margin.top - margin.bottom,
        totalHeight = singleSideHeight * 2;
    // let width = 400, height = 100;

    // define func for parsing date
    let paxTimeFormatStr = "%Y/%m/%d";
    let paxFormatTime = d3.timeFormat("%Y %b %d");
    let paxParseDate = d3.timeParse(paxTimeFormatStr);

    let wepTimeFormatStr = "%Y";
    let wepFormatTime = d3.timeFormat(wepTimeFormatStr);
    let wepParseDate = d3.timeParse(wepTimeFormatStr);

    // set scales for timeline
    let timelineScale = d3.scaleTime()
                          .range([0, width]);

    let info = d3.select("body")
                 .append("div")
                 .attr("id", "info");

    info.append("h1")
        .attr("id", "peaceProcessName")
        .text("");

    info.append("h1")
        .attr("id", "agreementTitle")
        .text("");

    info.append("h2")
        .attr("id", "signedDate")
        .text("");

    info.append("h2")
        .attr("id", "status")
        .text("");

    info.append("h2")
        .attr("id", "agreementType")
        .text("");

    // append SVG
    let svg = d3.select("body")
                .append("div")
                .attr("id", "svgContainer")
        // .style("height", totalHeight + "px")
                .append("div")
                .attr("id", "svgWrapper")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", totalHeight + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

    // INITIALIZE DATA  ---------------------------------------------------------------------------

    // Note: pax data needs to be sort already
    let gwno = d3.csv("./data/gwno.csv");
    let pax = d3.csv("./data/raw/pax_all_agreements_data.csv");
    let wep = d3.csv("./data/raw/world_economics_politics.csv");


    let tooltipDiv;

    let wepData;
    let wepKeys;

    let agreements;
    let agreementKeys;

    const LinePosition = {
        TOP: "top",
        BOTTOM: "bottom",
    };

    pax.then(d => {
        const nonLinearFields = ['Con', 'Contp', 'PP', 'PPName', 'Reg', 'AgtId', 'Agt', 'Dat', 'Status',
            'Lgt', 'N_characters', 'Agtp', 'Stage', 'StageSub', 'Part', 'ThrdPart', 'OthAgr',
            'Loc1ISO', 'Loc2ISO', 'Loc1GWNO', 'Loc2GWNO',
            'UcdpCon', 'UcdpAgr', 'PamAgr', 'CowWar'];

        d.forEach(d => {
            d.Dat = paxParseDate(d.Dat); // replace date string with processable date objects
        });
        agreements = d;
        timelineScale.domain(d3.extent(d, d => d.Dat));
        agreementKeys = Object.keys(d[0])
                              .filter(col => !(nonLinearFields.includes(col)));

        // add pax attribute dropdown list
        let paxDropdownList = d3.select("body")
                                .insert("select")
                                .attr("id", "paxDropdownList")
                                .on("change", paxColDropdownChanged);

        paxDropdownList.selectAll("option")
                       .data(agreementKeys)
                       .enter()
                       .append("option")
                       .attr("value", d => d)
                       .text(d => d);

        function paxColDropdownChanged() {

            const SELECTED_PAX_COL = getPAXValue();
            const GWNO_CODE = getGWNOValue();

            let filteredAgreements = filterAgreementsByGWNO(agreements, GWNO_CODE);
            //
            // d3.selectAll('rect')
            //   .data(filteredAgreements);

            d3.selectAll(".agreementMark")
              .data(filteredAgreements)
              .transition()
              .duration(500)
              .style("fill", d => {
                  let colorValue = d[SELECTED_PAX_COL];
                  if (colorValue == 0) {
                      return "rgba(124,128,125,0.66)"
                  } else if (colorValue == 1) {
                      return "#62A399"
                  } else if (colorValue == 2) {
                      return "#BE8675"
                  } else if (colorValue == 3) {
                      return "#993F3B"
                  }
              })
              .attr("height", 90);
        }

        /**
         *  Initialize the time line and circle tooltips.
         *
         */
        function initialize() {
            // draw timeline
            svg.append("g")
               .attr("id", "timeline")
               .attr("transform", "translate(0," + singleSideHeight + ")")
               .transition()
               .duration(2000)
               .call(d3.axisBottom(timelineScale)
                       .ticks(30))
               .selectAll("text")
               .style("text-anchor", "end")
               .attr("dx", "1em")
               .attr("dy", "0em")
               .attr("transform", "rotate(-65)");

            // Define the div for the tooltip
            tooltipDiv = d3.select("body")
                           .append("div")
                           .attr("class", "tooltip")
                           .style("opacity", 0);
        }

        initialize();
        drawAgreementsOnAxis(filterAgreementsByGWNO(agreements, getGWNOValue()));
        initializeWEP();
    });

    function initializeWEP() {
        const nonLinearFields = ['country', 'year', 'gwno', 'ccode', 'ifscode', 'ifs', 'gwabbrev']
        wep.then(d => {
            d.forEach(row => {
                row.year = wepParseDate(row.year);
                Object.keys(row)
                      .filter(k => !(nonLinearFields.includes(k)))
                      .forEach(key => {
                          row[key] = parseFloat(row[key]);
                      })
            });
            wepData = d;
            wepKeys = Object.keys(d[0])
                            .filter(col => !(nonLinearFields.includes(col)));

            defineDataColSelectionDropdownList(LinePosition.TOP);
            defineDataColSelectionDropdownList(LinePosition.BOTTOM);

            drawDataLine(getGWNOValue(), getWEPColValue(LinePosition.TOP), LinePosition.TOP);
            drawDataLine(getGWNOValue(), getWEPColValue(LinePosition.BOTTOM), LinePosition.BOTTOM);
        });

        function defineDataColSelectionDropdownList(pos) {
            // add wep attribute dropdown list
            let dropdownList = d3.select("body")
                                 .insert("select")
                                 .attr("class", "dataLineDropdownList " + pos)
                                 .on("change", () => {
                                     clearLinePlotsByPosition(pos);
                                     console.log("CLEAR: " + pos);
                                     drawDataLine(getGWNOValue(), getWEPColValue(pos), pos);
                                     console.log("DRAW: " + pos);
                                 });

            dropdownList.selectAll("option")
                        .data(wepKeys)
                        .enter()
                        .append("option")
                        .attr("value", d => d)
                        .text(d => d);
        }
    };


    /**
     * Clear all current plots except timeline. This including all the WEP data lines,
     * all the shapes that mark the WEP data points
     * and all the shapes that mark the peace agreements on the timeline.
     *
     */
    const CLEAR_DURATION = 1000;

    function clearAllPlotsExceptTimeline() {
        clearAllLinePlots();
        clearAllAgreementMarks();
    }

    function clearAllLinePlots() {
        d3.selectAll(".line")
          .transition()
          .duration(CLEAR_DURATION)
          .style("opacity", 0)
          .remove();
        d3.selectAll(".dot")
          .transition()
          .duration(CLEAR_DURATION)
          .style("opacity", 0)
          .remove();
    }

    function clearLinePlotsByPosition(pos) {
        d3.selectAll(".line." + pos)
          .transition()
          .duration(CLEAR_DURATION)
          .style("opacity", 0)
          .remove();
        d3.selectAll(".dot." + pos)
          .transition()
          .duration(CLEAR_DURATION)
          .style("opacity", 0)
          .remove();
        console.log("C;")
    }

    function clearAllAgreementMarks() {
        d3.selectAll(".agreementMark")
          .transition()
          .duration(CLEAR_DURATION)
          .attr("width", 0)
          .remove()
    }

    function getGWNOValue() {
        return d3.select("#countryDropdownList")
                 .property('value');
    }

    function getPAXValue() {
        return d3.select("#paxDropdownList")
                 .property('value');
    }

    function getWEPColValue(pos) {
        return d3.select(".dataLineDropdownList." + pos)
                 .property('value');
    }

    // generate country selection list
    gwno.then(data => {

        // add country dropdown list
        let countryDropdownList = d3.select("body")
                                    .insert("select")
                                    .attr("id", "countryDropdownList")
                                    .attr("class", "countryDropdownList")
                                    .on("change", GWNOCodeDropdownChange);

        countryDropdownList.selectAll("option")
                           .data(data)
                           .enter()
                           .append("option")
                           .attr("value", d => d.gwno)
                           .text(d => d.country);

        function GWNOCodeDropdownChange() {
            let GWNO_CODE = getGWNOValue();

            let filteredAgreements = filterAgreementsByGWNO(agreements, GWNO_CODE);

            clearAllPlotsExceptTimeline();
            drawAgreementsOnAxis(filteredAgreements, GWNO_CODE);
            drawDataLine(GWNO_CODE, getWEPColValue(LinePosition.TOP), LinePosition.TOP);
            drawDataLine(GWNO_CODE, getWEPColValue(LinePosition.BOTTOM), LinePosition.BOTTOM);
        }
    });

    // TODO: change `pos` to position based object info, which is adaptive with the timeline
    /**
     * Draw WEP data line on the specified position `pos` argument
     * @param {number} gwnoCode - the gwno code for the selected wep data
     * @param {string} col - the specified column to draw
     * @param {LinePosition} pos - either "top" or "bottom"
     */
    function drawDataLine(gwnoCode, col, pos) {

        let filteredData = wepData.filter(function (d) {
            if (d["gwno"] == gwnoCode && (d[col] !== "") && !isNaN(d[col])) {
                return d;
            }
        });

        if (filteredData.length === 0) {
            console.log("No data for column " + col);
            // TODO: show no data found info in the user interface
        }

        let yScale;

        if (pos === LinePosition.TOP) {
            yScale = d3.scaleLinear()
                       .range([singleSideHeight, margin.top + 50]);
        } else if (pos === LinePosition.BOTTOM) {
            yScale = d3.scaleLinear()
                       .range([singleSideHeight, totalHeight]);
        } else {
            console.error("Invalid Position argument:" + pos)
        }

        yScale.domain([0, d3.max(filteredData, function (d) {
            return d[col];
        })]);

        // draw lines on the timeline ---------------------------------------------------------------
        let valueLine = d3.line()
                          .x(d => {
                              return timelineScale(d.year)
                          })
                          .y(d => {
                              return yScale(d[col])
                          })
                          .curve(d3.curveMonotoneX);

        // add lines
        let path = svg.append("path")
                      .data([filteredData])
                      .attr("class", "line " + pos)
                      .attr("d", valueLine)
                      .style("opacity", 0)
                      .transition()
                      .duration(1000)
                      .style("opacity", 1);

        if (pos === LinePosition.TOP) {
            path.style("stroke", "#b06161")
        } else if (pos === LinePosition.BOTTOM) {
            path.style("stroke", "#686847");
        } else {
            console.error("Invalid Position argument")
        }

        // create interactive circles

        const MOUSE_OUT_CIRCLE_RADIUS = 5;
        const MOUSE_OVER_CIRCLE_RADIUS = 15;

        let circles = svg.selectAll(".newdot." + pos)
                         .data(filteredData)
                         .enter()
                         .append("circle") // Uses the enter().append() method
                         .attr("class", "dot " + pos) // Assign a class for styling
                         .attr("cx", d => timelineScale(d.year))
                         .attr("cy", d => yScale(d[col]))
                         .attr("r", MOUSE_OUT_CIRCLE_RADIUS)
                         .on("mouseover", function (d) {
                             d3.select(this)
                               .transition()
                               .duration(500)
                               .style("opacity", .2)
                               .style("fill", "white")
                               .attr("r", MOUSE_OUT_CIRCLE_RADIUS);
                             tooltipDiv.transition()
                                       .duration(200)
                                       .style("opacity", .9);
                             tooltipDiv.html(
                                 "<h6 class='title'>"
                                 + wepFormatTime(d.year)
                                 + "</h6>"
                                 + " "
                                 + col
                                 + "<br/>"
                                 + d[col])
                                       .style("left", (d3.event.pageX) + "px")
                                       .style("top", (d3.event.pageY - 28) + "px");
                         })
                         .on("mouseout", function (d) {
                             d3.select(this)
                               .transition()
                               .duration(500)
                               .style("opacity", 1)
                               .attr("r", MOUSE_OUT_CIRCLE_RADIUS)
                               .style("fill", "black");
                             tooltipDiv.transition()
                                       .duration(500)
                                       .style("opacity", 0);
                         })
                         .style("opacity", 0)
                         .transition()
                         .duration(1000)
                         .style("opacity", 1);

    }

    function filterAgreementsByGWNO(agreements, gwno) {
        return agreements.filter(function (d) {
            return d["Loc1GWNO"] == gwno || d["Loc2GWNO"] == gwno;
        });
    }

    function drawAgreementsOnAxis(agreementsToDraw) {
        agreementsToDraw.forEach(d => {
            let agreementBarWidth = 7;
            let mouseOutAgreementBarHeight = 50;
            let mouseOverAgreementBarHeight = 130;

            function peekAgreementInfo() {
                // TODO: expand timeline
                // svg.transition().duration(1000).attr("width", 2000);
                d3.select("#peaceProcessName")
                  .text(d.PPName);

                d3.select("#agreementTitle")
                  .text(d.Agt);

                d3.select("#status")
                  .text(d.Status);

                function formatAgtp(agtp) {
                    if (agtp === "Inter") {
                        return "Interstate/interstate conflict"
                    } else if (agtp === "InterIntra") {
                        return "Interstate/mixed or intrastate conflict"
                    } else if (agtp === "Intra") {
                        return "Intrastate agreement relating to intrastate conflict"
                    } else if (agtp === "IntraLocal") {
                        return "intrastate conflict mainly aiming to resolve local issues"
                    } else {
                        console.error("Error Agtp")
                    }
                }

                d3.select("#agreementType")
                  .transition()
                  .duration(1000)
                  .text(formatAgtp(d.Agtp));

                d3.select("#signedDate")
                  .html("Signed/Agreed on " + paxFormatTime(d.Dat) + '<sup><a href="https://google.com">*</a></sup>');

                rect.transition()
                    .duration(200)
                    .attr("height", mouseOverAgreementBarHeight);
            }

            function hidAgreementInfo() {

                rect.transition()
                    .duration(200)
                    .attr("height", mouseOutAgreementBarHeight);
            }

            let rect = svg.append("rect")
                          .attr("class", "agreementMark")
                          .on("mouseover", peekAgreementInfo)
                          .on("mouseout", hidAgreementInfo)
                          .attr("x", timelineScale(d.Dat))
                          .attr("y", singleSideHeight - 10)
                          .style("opacity", 0.5)
                          .attr("width", agreementBarWidth)
                          .attr("height", 0);

            rect.transition()
                .duration(1000)
                .attr("height", mouseOutAgreementBarHeight);
        });

        // d3.selectAll("rect")
        //   .data(agreementsToDraw);
    }

</script>
</body>
</html>